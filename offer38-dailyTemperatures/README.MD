# 最小时间差
## 题目
输入一个数组，它的每个数字是某天的温度。请计算需要等几天才会出现更高的温度。例如，如果输入数组【35，31，33，36，34】，那么输出为【3，1，1，0，0】。由于第1天的温度是35°C，要等3天才会出现更高的温度36°C，后面没有更高的温度，它对应的输出是0。其他的以此类推。
## 思路
解决这个问题的思路总结起来就是用一个栈保存每天的温度在数组中的下标。每次从数组中读取一个温度，然后将其与栈中保存的温度（根据下标可以得到温度）进行比较。如果当前温度比位于栈顶的温度高，那么就能知道位于栈顶那一天需要等待几天才会出现更高的温度。然后出栈1次，将当前温度与一个位于栈顶的温度进行比较。如果栈中已经没有比当前温度低的温度，则将当前温度在数组中的下标入栈。
## code
```java
package offer38;

import java.util.Stack;

public class Offer {
	//定义一个方法dailyTemperatures，接受一个整型数组temperatures作为参数，返回一个整型数组
	public int[] dailyTemperatures(int[] temperatures) {
		//创建一个输入数组temperatures长度相同的结果数组result，默认初始化为0
		int[] result = new int[temperatures.length];
		//创建一个栈，用于存储温度数组中的索引
		Stack<Integer> stack=new Stack<>();
		//遍历温度数组中的每一个温度
		for(int i=0;i<temperatures.length;i++) {
			//当栈不为空并且当前温度大于栈顶索引对应的温度时，表示找到了栈顶索引对应的那一天的下一个更暖和的日子
			while(!stack.empty()&&temperatures[i]>temperatures[stack.peek()]) {
				//弹出栈顶元素，得到一个需要计算等待天数的索引
				int prev=stack.pop();
				//计算当前温度与前一个温度之间的天数差，并将其存入结果数组中
				result[prev]=i-prev;
			}
			//将当前温度索引压入栈中
			stack.push(i);
		}
		//返回结果数组
		return result;
	}
}
```
## 这道题为什么要用栈
使用栈解决这道题的原因在于栈的特性非常适合处理“下一个更大元素”这类问题，尤其是在需要高效地追踪和计算等待时间的情况下。具体来说，栈在这道题中的作用可以总结为以下几点：
### 1.栈的后进先出（LIFO）特性：
* 在处理温度时，我们关心的是“当前温度相比之前的温度是否更高”。栈的后进先出特性允许我们从最近处理的温度开始比较，这正是我们需要的行为。
* 栈顶的元素代表最近一个未找到比它更高温度的索引，如果当前温度更高，那么这个温度就是栈顶元素等待的那个更高温度。通过这种方式，我们能够从栈顶向下逐步处理所有未处理的温度。  
### 2.避免重复计算，节省时间：
* 如果不使用栈，可能需要双重循环来逐一比较每一天的温度，这样的算法在最坏情况下时间复杂度是 O(n^2)，效率低下。  
* 使用栈则能将时间复杂度降低到 O(n)。每个温度索引最多只会被压入和弹出栈一次，这意味着我们只需遍历一次温度数组并在每次遍历时做少量的栈操作，从而避免了重复计算。
### 3.高效处理“下一个更大元素”问题：
* 栈非常适合解决“下一个更大元素”这类问题，因为栈能帮我们有效地跟踪并比较前后元素。每当找到一个更大的元素时，我们可以直接从栈中弹出之前的小元素，并且立即确定这些小元素的最终答案。  
* 在这道题中，当我们找到一个比栈顶温度更高的温度时，可以立刻确定栈顶元素对应的天数要等待多少天，从而有效地填充结果数组。 
### 4.自动维护顺序
* 栈自动维护了一个从栈底到栈顶“递减”的顺序（即栈顶的温度比栈底的温度低），因为在遍历过程中，只有当前温度比栈顶温度低时，我们才会将当前索引压入栈中。
* 这使得每次从栈中弹出元素时，我们能够非常明确地知道当前处理的温度比栈顶温度要高，从而可以确定等待天数。
### 总结
使用栈是因为它能够高效地处理“下一个更大元素”问题，并且栈的结构能够天然的帮助我们管理和比较先前的元素，避免了不必要的重复比较，极大地提升了算法的效率。





