# 直方图最大矩形面积
## 题目
直方图是由排列在同一基线上的相邻柿子组成的图形。输入一个由非负数组成的数组，数组中的数字是直方图中柱子的高。求直方图中最大矩形面积。假设直言方图中柱子的宽都为1.例如，输入数组[2,1,5,6,2,3]，其对应的直方图如图所示，该直方图中最大矩形面积为12，如阴影部分所示  
<img src="https://github.com/meatball-RUI/DataStructure-and-Algorithm-Offer/blob/main/offer39-largestRectangleArea/Screenshot%202024-09-03%20at%2011.15.47.png" width="350px">
<img src="https://github.com/meatball-RUI/DataStructure-and-Algorithm-Offer/blob/main/offer39-largestRectangleArea/histogram_area.png" width="350px">
## 解决方法
### 蛮力法
如果能逐一找出直方图中所有的矩形并比较它们的面积，就能得到最大的矩形面积。下面使用嵌套的二重循环遍历所有矩形，并比较它们的面积，参考代码如下所示
```java
package offer39;
public class Solution1 {
	// Function to calculate the largest rectangle area in a histogram
	// 计算直方图中最大矩形面积的函数
	public int largestRectangleArea(int[] heights) {
		//Variable to store the maximum area found
		//用于存储找到的最大面积的变量
		int maxArea=0;
		//Outer loop to consider each bar as the left boundary of the rectangle
		//外层循环，将每个柱子作为矩形的左边界
		for(int i=0;i<heights.length;i++) {
			
			//Initialize the minimum height to the current bar
			//将最小高度初始化为当前柱子的高度
			int min=heights[i];
			
			//Inner loop to consider each bar from 'i' as the right boundary
			//内层循环，将从‘i’开始的每个柱子作为右边界
			for(int j=i;j<heights.length;j++) {
				//Update the minimum height between the bars from 'i' to 'j'
				//更新从‘i’到‘j’之间柱子的最小高度
				min=Math.min(min, heights[j]);
				//Calculate the area with 'i' as the left boundary and 'j' as the right boundary
				//计算以‘i’为左边界，‘j’为右边界的矩形面积
				int area=min*(j-i+1);
				//Update the maximum area if the current area is larger
				//如果当前面积最大，则更新最大面积
				maxArea=Math.max(maxArea, area);
			}
		}
		//Return the maximum area found
		//返回找到的最大面积
		return maxArea;
	}
}
```
#### 时间空间复杂度
时间复杂度O（n^2）,空间复杂度O（n）

### 分治法
使用分治法(Divide and Conquer)来解决最大矩形面积的问题是一种更高效的算法。分治法的核心思想是将问题递归地分成更小的子问题进行解决，然后将子问题的解组合成原问题的解。   
分治法解决最大矩形面积的步骤：   
1. 找出最小高度的柱子   
* 在给定的范围内找到最矮的柱子（高度最小的柱子）。这个柱子决定了以它为高度的矩形的最大宽度。  
* 因为这个柱子将直方图分成了两部分，左边部分和右边部分  
2. 递归地计算左半部分和右半部分的最大矩形面积  
* 左半部分的最大矩形面积可以通过递归调用相同的函数来计算    
* 右半部分的最大矩形面积也可以通过递归调用相同的函数来计算   
3. 结合结果：  
* 最后的最大矩形面积是三者中的最大值  
1.通过最矮柱子计算得到矩形的面积  
2.左半部分的最大矩形面积    
3.右半部分的最大矩形面积   
代码实现：  
```java
package offer39;

public class ConquerAndDivideRUI1{
	//用来计算矩形最大值的函数
	public int largestRectangle(int[] heights) {
		//调用辅助方法用来计算所有范围内的最大矩形面积值
		return helper(heights,0,heights.length);
	}
	//递归辅助函数，用来计算子数组中的最大矩形面积值
	private int helper(int[] heights, int start, int end) {
		//遍历数组，找到最小高度的柱子的索引
		int minIndex=start;
		for(int i=0;i<heights.length;i++) {
			if(heights[i]<heights[minIndex]) {
				minIndex=i;
			}
		}
		//递归计算左半部分最大矩形值
		int areaMinIndex=minIndex*(start-end+1);
		//递归计算左半部分最大矩形值
		int areaLeft=helper(heights,start,minIndex-1);
		//递归计算右半部分最大矩形值
		int areaRight=helper(heights,minIndex+1,end);
		return Math.max(areaMinIndex, Math.max(areaLeft, areaRight));
	}
}

```
#### 时间空间复杂度
##### 时间复杂度  
* 假设输入数组的长度为n。如果每次都能将n根柱子分成两根柱子数量为n/2的直方图，那么递归调用的深度为O（logn），整个分治法的时间复杂度是O（nlogn）  
* 但如果直方图中柱子的高度是排序的（递增排序或递减排序），那么每次最矮的柱子都位于直方图的一侧，递归调用的深度就是O（n），此时分治法的时间复杂度也变成O（n^2)  
###### 空间复杂度  
1.递归调用栈的深度：   
* 在最坏情况下，递归调用的深度会达到 O(n)，这就是空间复杂度的主要来源。  
* 每一层递归调用会占用 O(1) 的空间，但由于调用栈的深度可能达到 O(n)，所以总的空间复杂度为 O(n)。    
2.额外的空间使用：  
* 除了递归调用栈外，算法在每次递归中只使用了常量级别的额外空间（例如变量minIndex、area、left、right），所以不影响总体空间复杂度。   

综上所述：
* 时间复杂度：O（^2)
* 空间复杂度：O（n）
该算法的时间复杂度较高，特别是在最坏情况下，效率会比较低。这也是为什么通常会使用更高效的算法（例如基于栈的线性时间算法）来解决这个问题。


### 单调栈法
#### 解题思路
1. 定义问题：  
* 给定一个柱状图，每个柱子的高度由数组heights表示，求在这个柱状图中能形成的最大矩形的面积  
2. 使用单调栈：  
* 单调栈的概念：使用栈来维护柱子的索引，使用栈中的柱子的高度是单调递增的。这样可以方便地计算每个柱子作为最小高度时的最大矩形面积。  
3. 处理柱子：  
* 遍历柱状图的每个柱子时，将柱子的索引压入栈中。  
* 在压入新柱子之前，比较栈顶柱子的高度与当前柱子的高度。如果当前柱子的高度较小，弹出栈顶元素，并计算以栈顶柱子的高度为基准的矩形的面积。更新最大矩形面积。  
4. 计算矩形面积  
* 当弹出栈顶柱子时，计算该柱子作为最小高度的矩形的面积。矩形的宽度是从栈中下一个柱子的索引到当前柱子的索引之间的距离。  
5. 处理剩余柱子  
* 遍历结束后，栈中可能还有未处理的柱子。继续弹出栈顶的柱子，计算其矩形面积。这些柱子的宽度会是从当前柱子的索引到柱状图的末尾。

##### 详细步骤
1. 初始化：  
* 创建一个栈用于存储柱子的索引
* 在栈中先推入一个特殊值-1，作为栈的虚拟左边办。
2. 遍历柱状图
* 对于每个柱子，进行如下操作：  
	*  如果栈不为空且当前柱子的高度小于或等于栈顶柱子的高度，则弹出栈顶柱子的索引，并计算以该柱子为最小高度的矩形面积  
	*  将当前柱子的索引推入栈中。  
3. 处理栈中剩余的柱子：
* 在遍历结束后，栈中仍有柱子未处理。弹出这些柱子的索引，计算其对应的矩形面积  
4. 计算面积：  
* 计算每个弹出的柱子的矩形面积时，宽度是当前柱子的索引减去栈顶柱子的索引减一  

##### 示例  
假设柱状图的高度数组为【2，1，5，6，2，3】：  
步骤 1: 初始化  
* 初始化一个栈并将 -1 推入栈中，作为虚拟的左边界。  
* stack = [-1]  
* maxArea = 0  
步骤 2: 遍历柱状图  
1. 柱子高度为2（索引0）
* 将索引0推入栈中。  
* stack = [-1,0]  
2. 柱子高度为1（索引1）  
* 当前柱子的高度1小于栈顶柱子的高度2.
* 弹出栈顶元素0，计算以高度2为基准的矩形面积
* 宽度=1【右边界，当前遍历到的元素的索引】-（-1）【栈顶元素的前一个元素索引】-1=1
* 面积=2*1=1
3. 处理柱子高度为5（索引2）：
* 将索引2推入栈中，栈为【-1，1，2】。
4. 处理柱子高度为6（索引3）：
* 将索引3推入栈中，栈为【-1，1，2，3】。
5.处理柱子高度为2（索引4）：  
* 当前柱子的高度2小于栈顶柱子的高度6，弹出栈顶元素3，并计算以高度6为基准的矩形面积。
* 高度：栈顶元素对应的高度是6.
* 宽度：宽度计算为4-2-1=1，此时stack.peek()是2.
* 面积：6*1=6  
接着，继续弹出栈顶元素2，并计算心高度5为基准的矩形面积：
* 高度：栈顶元素对应的高度是5.  
* 宽度：宽度计算4-1-1=2，此时stack.peek()是1.
* 面积： 5 * 2=10  
最后的处理
当遍历完所有柱子后，栈中可能还剩一些柱子，这些柱子的右边界是整个柱状图的末尾(heights.length)。因此，我们继续弹出栈中的柱子，并计算这些柱子的矩形面积。
* 右边界：heights.length,代表矩形能够扩展到图的末尾
* 左边办：栈中弹出栈顶元素后的新栈顶元素  
总结：
* 右边界：当前遍历到的柱子是第一个高度小于栈顶柱子的，栈顶柱子的右边办就是这个柱子的索引。
* 左边界：栈顶柱子弹出后，新的栈顶元素代表了栈顶柱子左侧第一个小于它的柱子，它是左边界。
* 宽度：右边界减去左边界再减去1，公式为i-stack.peek()-1,其中i是当前柱子的索引，stack.peek()是新的栈顶元素。

#### 为什么宽度不能直接是当前元素减去栈顶元素索引呢？（其实还不是很理解）
宽度不能直接是当前元素索引减去栈顶元素索引的原因在于，栈顶柱子实际上只从栈顶的下一个柱子（新的栈顶柱子）向右延伸，而不是从当前柱子向右延伸。如果你只用当前元素的索引减去栈顶元素的索引，就会错过那此位于栈顶元素左边、并且比栈顶元素矮的柱子。  
##### 栈的结构
栈中存储的柱子的索引，这些柱子按照高度从低到高排列。当前元素的高度小于栈顶元素时，栈顶元素所能形成的最大矩形的左边界是栈中下一个元素，它是第一个小于栈顶柱子的元素，右边是当前元素。
##### 举例说明
假设柱状图为【2，1，5，6，2，3】，我们来看如何使用栈来计算最大矩形面积。  
1. 处理柱子高度为2（索引0）：
* 将索引0推入栈，栈为【-1，0】
2.处理柱子度为1（索引1）：
* 当前柱子1小于栈顶柱子2，弹出栈顶元素0并计算以柱子2为高度的矩形面积。
* 右边界：是当前元素的索引1，因为柱子1限制了栈顶元素2向右的扩展
* 左边界：弹出栈顶元素后，新的栈顶是-1，表示柱子2能向左扩展到的最远的位置（虚拟的左边界）。
* 宽度：1-（-1）-1=1。
* 面积：2*1=2  
如果你用当前元素的索引减去栈顶元素的索引来计算宽度，公式将变成1-0=1，看似结果一样，但在更复杂的情况下就会产生错误的计算。  
为什么要减去stack.peek()+1  
这是因为栈中的柱子不仅记录当前弹出的柱子本身，还记录了该柱子在左边可以向左扩展的最远的位置，即弹出栈顶元素后，新的栈顶元素定义了它的左边界。当前柱子的位置定义了栈顶柱子的右边办。因此，正确的宽度公式为i-stack.peek()-1.  
举例说明更复杂的情况  
柱状图【2，1，5，6，2，3】：   
3. 处理柱子高度为6（索引3）：  
* 将索引3推入栈中，栈为【-1，1，2，3】  
4. 处理柱子高度为2（索引4）：  
* 当前柱子2小于栈顶柱子6，弹出栈顶元素3并计算以高度6为基准的矩形面积。   
* 右边界：当前柱子2限制了栈顶柱子6的右扩展。  
* 左边界：弹出栈顶元素后，新的栈顶元素是2，所以柱子6的左边界是2右边的第一个位置  
* 宽度： 4-2-1=1.  
* 面积： 6*1=6.  
接着，弹出栈顶柱子5并计算其面积：  
* 右边界：依然是当前柱子2的索引4.  
* 左边界：栈中新的栈顶元素1代表柱子5向左扩展的最远位置。 
* 宽度：4-1-1=2.  
* 面积：5*2=10。   
总结  
直接用当前元素的索引减去栈顶元素的索引来计算宽度，忽略了栈中元素的左边界（栈顶下一个元素）是柱子能够扩展的真正左侧边界。因此，我们需要用i-stack.peek()-1来计算宽度，确保矩形能够正确地扩展到它的左边界。

#### 为什么要有一个虚拟的左边界
在单调栈法中使用虚拟左边界（通常是 -1）是为了简化计算和处理边界条件。以下是为什么需要虚拟左边界的详细解释：  
1. 简化宽度计算  
虚拟左边界使得我们能够更方便地计算矩形的宽度。特别是对于栈中的第一个元素（最左边的柱子）来说，虚拟左边界提供了一个清晰的左边界，使得我们在计算面积时不会出现边界条件的问题。    
没有虚拟左边界时：  
* 当栈中只剩下一个柱子时（例如，当栈中只有柱子 2 的索引），计算矩形的宽度将会变得复杂。因为你需要手动处理宽度从栈中元素的起始位置到当前索引的距离。  
有虚拟左边界时：  
* 当计算面积时，无论栈中有多少柱子，虚拟左边界提供了一个统一的左边界，使得宽度计算非常直接和一致。
* 例如，宽度计算为 i - stack.peek() - 1，这里的 stack.peek() 可以是虚拟的 -1，这保证了宽度计算从柱子索引 0 开始一直到当前柱子 i 的正确距离。  
2. 处理边界柱子  
虚拟左边界也帮助处理柱状图中最左边的柱子。在计算这些柱子作为最小高度时的面积时，如果没有虚拟左边界，我们需要特殊处理这些柱子的位置，可能会增加代码复杂性。  
示例：  
考虑柱状图 heights = [2, 1, 5, 6, 2, 3]，假设我们正在处理柱子 2 （索引 4）之前的柱子：  
* 当stack为空时（除了虚拟左边界），这时候 stack.peek() 为虚拟左边界 -1，这样计算的宽度直接为从 -1 到当前柱子 4 的宽度，即 4 - (-1) - 1 = 4。  
3.一致性和简洁性  
虚拟左边界提供了一种一致的方式来处理所有的柱子，不论是栈中只有一个柱子还是多个柱子。它避免了在计算矩形宽度时需要对边界进行特殊处理的复杂性，使得代码更简洁、更易于理解和维护。  
总结  
虚拟左边界在单调栈法中主要用于简化宽度计算和处理边界条件，使得算法能够在处理柱状图的每个柱子时更加一致和简洁。通过使用虚拟左边界，可以确保所有的柱子都有一个明确的左边界，从而更容易计算矩形的面积。

#### 为什么这道题中要用到栈
在柱状图中求解最大矩形面积的问题中，使用栈是一种高效的方式，因为栈可以帮助我们快速找到每个柱子作为矩形高度时能够扩展的宽度。下面是为什么要使用栈以及栈如何帮助解决这个问题的详细解释：  
为什么要用栈  
1.高效寻找柱子的左右边界:  
* 为了计算每个柱子作为矩形高度时的面积，我们需要找到这个柱子能够扩展的最大宽度。即，找到柱子左侧和右侧的边界（在柱子高度不低于当前柱子的情况下）  
* 使用栈可以帮助我们高效地找到这些边界。当我们遍历柱子时，可以通过栈来记录当前柱子的索引，从而在需要时快速找到第一个较低的柱子（即，找到左右边界） 
2.单调性保证:  
* 栈中的柱子索引是按高度单调递增的。这样，当我们遇到较低的柱子时，可以通过栈来弹出较高的柱子，并计算其面积。这种单调性保证了每次弹出的柱子是当前可以形成最大面积的柱子，从而避免了重复计算。  
栈如何帮助解决问题  
1.保持单调递增:  
* 在遍历柱子时，栈的单调递增特性使得栈中的柱子总是按高度从低到高排列。这使得每个柱子都可以被快速地处理，即找到其对应的左右边界。  
2.处理较低的柱子:  
* 当遇到较低的柱子时（即当前柱子的高度小于栈顶柱子的高度），我们可以弹出栈顶元素，计算以栈顶柱子高度为基础的矩形面积。宽度计算为当前柱子索引与栈中下一个元素索引之间的距离。  
3.计算剩余柱子的面积  
* 遍历结束后，栈中可能还剩下未处理的柱子。此时，可以将这些柱子弹出，并计算它们的矩形面积。此时宽度计算为从当前柱子索引到柱状图末尾的距离。 

#### 单调栈code
#### offer书上的
```java
package offer39;

import java.util.Stack;

public class MonotonicStackRUI {
	public int largestRectangle(int[] heights) {
		//创建一个用来存放索引的栈
		Stack<Integer> index=new Stack<>();
		//在栈中放入一个元素-1，用来表示栈空时的左边界
		index.push(-1);
		//用一个变量来保存最大矩形面积值
		int maxArea=0;
		//遍历所有柱子
		for(int i=0;i<heights.length;i++) {
			//如果当前栈不为空，且当前柱子高度小于等于栈顶中索引所对应的柱子高度，那么计算以最高柱子为高所对应的最大面积
			while(index.peek()!=-1&&heights[i]<=heights[index.peek()]) {
				//确定最高柱子高度
				int height=heights[index.pop()];
				//确定宽度,左边界为弹出最高柱子的下一个柱子索引
				int width=i-index.peek()-1;
				maxArea=Math.max(maxArea, height*width);
			}
			index.push(i);
		}
		//处理剩余栈中的柱子
		while(index.peek()!=-1) {
			int height=heights[index.pop()];
			int width=heights.length-index.peek()-1;
			//更新最大矩形面积
			maxArea=Math.max(maxArea, height*width);
		}
		return maxArea;
	}
}
```
#### 错题集
```java
package offer39;

import java.util.Stack;

public class MonotonicStackRUI {
	public int largestRectangle(int[] heights) {
		//创建一个用来存放索引的栈
		Stack<Integer> index=new Stack<>();
		//在栈中放入一个元素-1，用来表示栈空时的左边界
		index.push(-1);
		//用一个变量来保存最大矩形面积值
		int maxArea=0;
		//遍历所有柱子
		for(int i=0;i<heights.length;i++) {
			//如果当前栈不为空，且当前柱子高度小于等于栈顶中索引所对应的柱子高度，那么计算以最高柱子为高所对应的最大面积
			if(index.peek()!=-1&&heights[i]<=heights[index.peek()]) {
				//确定最高柱子高度
				int height=heights[index.pop()];
				//确定宽度,左边界为弹出最高柱子的下一个柱子索引
				int width=i-index.peek()-1;
				maxArea=Math.max(maxArea, height*width);
			}
			index.push(i);
		}
		//处理剩余栈中的柱子
		while(index.peek()!=-1) {
			int height=heights[index.pop()];
			int width=heights.length-index.peek()-1;
			//更新最大矩形面积
			maxArea=Math.max(maxArea, height*width);
		}
		return maxArea;
	}
}
```
错题分析  
相同高度柱子重复计算：只在 heights[i] <= heights[index.peek()] 时弹出栈顶的柱子，但如果当前柱子的高度小于等于一下个栈顶柱子时，理论上还应该继续弹出栈中的柱子，因为这些柱子同样需要计算它们的矩形面积。  
修复建议：  
你应该用 while 循环来保证当前柱子小于等于栈顶的柱子高度时，不断弹出栈顶元素，直到栈顶元素的柱子高度小于当前柱子高度。  












